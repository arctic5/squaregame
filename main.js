// Generated by CoffeeScript 1.8.0
(function() {
  var Component, DOWN, Entity, LEFT, Player, RIGHT, Sys, UP, currentKey, keybyte, lastKey, __count, __entities;

  __entities = [];

  __count = 0;

  currentKey = null;

  lastKey = null;

  keybyte = 0x0;

  LEFT = 0x1;

  RIGHT = 0x2;

  UP = 0x4;

  DOWN = 0x8;

  Entity = (function() {
    function Entity() {
      this.id = (+new Date()).toString(16) + (Math.random() * 100000000 | 0).toString(16);
      this.components = {};
      __entities.push(this);
      __count++;
    }

    Entity.prototype.addComponent = function(component) {
      return this.components[component.name] = component;
    };

    Entity.prototype.showData = function() {
      this.str = JSON.stringify(this, null, 4);
      console.log(this.str);
      return this.str;
    };

    return Entity;

  })();

  Component = {
    health: function(value) {
      this.name = "health";
      return this.value = value;
    },
    physics: function(x, y, vspeed, hspeed, friction, solid) {
      if (vspeed == null) {
        vspeed = 0;
      }
      if (hspeed == null) {
        hspeed = 0;
      }
      if (friction == null) {
        friction = 0.7;
      }
      if (solid == null) {
        solid = false;
      }
      this.name = "physics";
      this.x = x;
      this.y = y;
      this.vspeed = Math.min(vspeed, 4);
      this.hspeed = Math.min(hspeed, 4);
      return this.friction = friction;
    },
    sprite: function(frames, xorig, yorig, bbox) {
      this.name = "sprite";
      this.frames = frames;
      this.x = xorig;
      this.y = yorig;
      return this.bbox = bbox([0, frames[0].width, 0, frames[0].height]);
    },
    draw: function() {
      return this.name = "draw";
    },
    controllable: function() {
      return this.name = "controllable";
    }
  };

  Sys = {
    canvas: {
      init: function() {
        var _ref;
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        _ref = [600, 800], this.canvas.width = _ref[0], this.canvas.height = _ref[1];
        return this.rect = this.canvas.getBoundingClientRect();
      },
      clear: function() {
        this.ctx.save();
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        return this.ctx.restore();
      }
    },
    rendering: function(ent) {
      if (this.ent.components.draw) {
        Sys.canvas.clear();
        Sys.canvas.ctx.beginPath();
        return Sys.canvas.ctx.fillRect(this.ent.components.physics.x, this.ent.components.physics.y, 40, 40);
      }
    },
    input: {
      init: function() {
        window.addEventListener('keydown', (function(event) {
          switch (event.keyCode) {
            case 37:
              return keybyte |= LEFT;
            case 39:
              return keybyte |= RIGHT;
            case 40:
              return keybyte |= DOWN;
            case 38:
              return keybyte |= UP;
          }
        }), true);
        return window.addEventListener('keyup', (function(event) {
          switch (event.keyCode) {
            case 37:
              return keybyte &= LEFT;
            case 39:
              return keybyte &= RIGHT;
            case 40:
              return keybyte &= DOWN;
            case 38:
              return keybyte &= UP;
          }
        }), true);
      }
    },
    playercontrol: function() {
      if (this.ent.components.physics && this.ent.components.controllable) {
        switch (currentKey) {
          case 37:
            keybyte |= LEFT;
            break;
          case 39:
            keybyte |= RIGHT;
            break;
          case 40:
            keybyte |= DOWN;
            break;
          case 38:
            keybyte |= UP;
        }
        switch (lastKey) {
          case 37:
            return keybyte &= LEFT;
          case 39:
            return keybyte &= RIGHT;
          case 40:
            return keybyte &= DOWN;
          case 38:
            return keybyte &= UP;
        }
      }
    },
    movement: function() {
      if (this.ent.components.physics && this.ent.components.controllable) {
        if (keybyte & LEFT) {
          this.ent.components.physics.vspeed -= 5;
        }
        if (keybyte & RIGHT) {
          this.ent.components.physics.vspeed += 5;
        }
        if (keybyte & UP) {
          this.ent.components.physics.hspeed -= 5;
        }
        if (keybyte & DOWN) {
          this.ent.components.physics.hspeed += 5;
        }
        this.ent.components.physics.x += Math.min(Math.abs(this.ent.components.physics.vspeed), 7) * Math.sign(this.ent.components.physics.vspeed);
        this.ent.components.physics.y += Math.min(Math.abs(this.ent.components.physics.hspeed), 7) * Math.sign(this.ent.components.physics.hspeed);
        this.ent.components.physics.vspeed *= this.ent.components.physics.friction;
        return this.ent.components.physics.hspeed *= this.ent.components.physics.friction;
      }
    },
    loop: function() {
      var _i, _len;
      for (_i = 0, _len = __entities.length; _i < _len; _i++) {
        this.ent = __entities[_i];
        Sys.playercontrol();
        Sys.rendering();
        Sys.movement();
      }
      currentKey = null;
      lastKey = null;
      keybyte = 0x0;
      return setTimeout((function() {
        return requestAnimationFrame(Sys.loop);
      }), 1000 / 30);
    }
  };

  Player = (function() {
    function Player() {
      this.player = new Entity;
      this.player.addComponent(new Component.health(2));
      this.player.addComponent(new Component.physics(0, 0));
      this.player.addComponent(new Component.controllable());
      this.player.addComponent(new Component.draw());
      this.player.showData();
    }

    return Player;

  })();

  new Player;

  Sys.canvas.init();

  Sys.input.init();

  Sys.loop();

}).call(this);
